---
title: 线程与线程处理
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5049ed1b44155f3c21c53bef24a13006fe97a3fa
ms.sourcegitcommit: b22705f1540b237c566721018f974822d5cd8758
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/19/2018
ms.locfileid: "49452581"
---
# <a name="threads-and-threading"></a><span data-ttu-id="dc0e8-102">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="dc0e8-102">Threads and Threading</span></span>
<span data-ttu-id="dc0e8-103">操作系统使用进程隔开正在执行的不同应用。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-103">Operating systems use processes to separate the different applications that they are executing.</span></span> <span data-ttu-id="dc0e8-104">线程是操作系统向其分配处理器时间的基本单位，在相应进程内多个线程可以同时执行代码。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-104">Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.</span></span> <span data-ttu-id="dc0e8-105">每个线程负责维护异常处理程序、计划优先级，以及系统用来保存被排入计划前线程上下文的一组结构。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-105">Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.</span></span> <span data-ttu-id="dc0e8-106">线程上下文包含线程在其主机进程地址空间中顺畅继续执行所需的全部信息，包括线程的一组 CPU 寄存器和堆栈。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-106">The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.</span></span>  
  
 <span data-ttu-id="dc0e8-107">.NET Framework 将操作系统进程进一步细分为轻型托管子进程，称为“应用域”（由 <xref:System.AppDomain?displayProperty=nameWithType> 表示）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-107">The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc0e8-108">一个或多个托管线程（由 <xref:System.Threading.Thread?displayProperty=nameWithType> 表示）可以在同一个托管进程内的一个或任意多个应用域中运行。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-108">One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=nameWithType>) can run in one or any number of application domains within the same managed process.</span></span> <span data-ttu-id="dc0e8-109">尽管每个应用域一开始都只有一个线程，但相应应用域中的代码可能会创建其他应用域和其他线程。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-109">Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.</span></span> <span data-ttu-id="dc0e8-110">因此，托管线程可以在同一个托管进程内的不同应用域之间自由移动；可能只有一个线程在多个应用域之间移动。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-110">The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.</span></span>  
  
 <span data-ttu-id="dc0e8-111">支持强占式多任务的操作系统造成的效应是，同时执行多个进程中的多个线程。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-111">An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.</span></span> <span data-ttu-id="dc0e8-112">为此，它在有需求的线程之间分配可用处理器时间，相继向每个线程分配处理器时间片。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-112">It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.</span></span> <span data-ttu-id="dc0e8-113">当前正在执行的线程在时间片结束后暂停，另一个线程继续运行。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-113">The currently executing thread is suspended when its time slice elapses, and another thread resumes running.</span></span> <span data-ttu-id="dc0e8-114">如果系统从一个线程切换到另一个线程，它会保存强占线程的线程上下文，并重载线程队列中下一个线程的已保存线程上下文。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-114">When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.</span></span>  
  
 <span data-ttu-id="dc0e8-115">时间片长度具体视操作系统和处理器而定。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-115">The length of the time slice depends on the operating system and the processor.</span></span> <span data-ttu-id="dc0e8-116">由于每个时间片都很小，因此即使只有一个处理器，多个线程也可能同时执行。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-116">Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.</span></span> <span data-ttu-id="dc0e8-117">多处理器系统实际上正是如此，可执行线程在可用处理器之间进行分配。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-117">This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.</span></span>  
  
## <a name="when-to-use-multiple-threads"></a><span data-ttu-id="dc0e8-118">何时使用多个线程</span><span class="sxs-lookup"><span data-stu-id="dc0e8-118">When To Use Multiple Threads</span></span>  
 <span data-ttu-id="dc0e8-119">如果软件需要用户交互，必须尽可能快地回应用户活动，以便于提供丰富的用户体验。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-119">Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.</span></span> <span data-ttu-id="dc0e8-120">然而，与此同时，它还必须执行必要的计算，以尽可能快地向用户呈现数据。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-120">At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.</span></span> <span data-ttu-id="dc0e8-121">如果应用仅使用一个执行线程，可以结合使用[异步编程](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)和 [.NET Framework 远程处理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))或使用 ASP.NET 创建的 [XML Web 服务](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7bkzywba(v=vs.100))，这样不仅可以使用自己计算机的处理时间，还能使用其他计算机的处理时间，以提高响应用户的速度，并减少应用的数据处理时间。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-121">If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with [.NET Framework remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100)) or [XML Web services](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7bkzywba(v=vs.100)) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.</span></span> <span data-ttu-id="dc0e8-122">若要执行大量输入/输出工作，还可以使用 I/O 完成端口，以提高应用的响应速度。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-122">If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.</span></span>  
  
### <a name="advantages-of-multiple-threads"></a><span data-ttu-id="dc0e8-123">多个线程的优势</span><span class="sxs-lookup"><span data-stu-id="dc0e8-123">Advantages of Multiple Threads</span></span>  
 <span data-ttu-id="dc0e8-124">不过，使用多个线程是目前功能最强大的方法，不仅可以提高响应用户的速度，还能在几乎同时处理必要数据来完成工作。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-124">Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.</span></span> <span data-ttu-id="dc0e8-125">在具有一个处理器的计算机上，多个线程可以造成这样的效应，具体是通过利用用户事件之间的短时间段在后台处理数据。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-125">On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.</span></span> <span data-ttu-id="dc0e8-126">例如，用户可以编辑电子表格，同时另一个线程正在重新计算同一应用中此电子表格的其他部分。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-126">For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.</span></span>  
  
 <span data-ttu-id="dc0e8-127">无需修改，同一应用会在具有多个处理器的计算机上运行时，显著提高用户满意度。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-127">Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.</span></span> <span data-ttu-id="dc0e8-128">一个应用域可以使用多个线程来完成下列任务：</span><span class="sxs-lookup"><span data-stu-id="dc0e8-128">Your single application domain could use multiple threads to accomplish the following tasks:</span></span>  
  
-   <span data-ttu-id="dc0e8-129">通过网络与 Web 服务器和数据库通信。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-129">Communicate over a network, to a Web server, and to a database.</span></span>  
  
-   <span data-ttu-id="dc0e8-130">执行耗时很长的操作。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-130">Perform operations that take a large amount of time.</span></span>  
  
-   <span data-ttu-id="dc0e8-131">区分不同优先级的任务。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-131">Distinguish tasks of varying priority.</span></span> <span data-ttu-id="dc0e8-132">例如，高优先级线程管理时间要求严格的任务，低优先级线程执行其他任务。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-132">For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.</span></span>  
  
-   <span data-ttu-id="dc0e8-133">让用户界面能够一直响应用户，同时为后台任务分配时间。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-133">Allow the user interface to remain responsive, while allocating time to background tasks.</span></span>  
  
### <a name="disadvantages-of-multiple-threads"></a><span data-ttu-id="dc0e8-134">多个线程的缺点</span><span class="sxs-lookup"><span data-stu-id="dc0e8-134">Disadvantages of Multiple Threads</span></span>  
 <span data-ttu-id="dc0e8-135">建议尽量少使用线程，这样可以最大限度地减少使用操作系统资源，并提升性能。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-135">It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.</span></span> <span data-ttu-id="dc0e8-136">线程处理也有资源要求和潜在冲突，需要在设计应用时纳入考虑范围。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-136">Threading also has resource requirements and potential conflicts to be considered when designing your application.</span></span> <span data-ttu-id="dc0e8-137">资源要求如下：</span><span class="sxs-lookup"><span data-stu-id="dc0e8-137">The resource requirements are as follows:</span></span>  
  
-   <span data-ttu-id="dc0e8-138">系统使用内存来保存进程、AppDomain 对象和线程所需的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-138">The system consumes memory for the context information required by processes, **AppDomain** objects, and threads.</span></span> <span data-ttu-id="dc0e8-139">因此，可以创建的进程数、AppDomain 对象数和线程数受可用内存限制。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-139">Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.</span></span>  
  
-   <span data-ttu-id="dc0e8-140">跟踪大量线程会消耗非常多的处理器时间。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-140">Keeping track of a large number of threads consumes significant processor time.</span></span> <span data-ttu-id="dc0e8-141">如果线程太多，其中大多数都不会取得重大进展。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-141">If there are too many threads, most of them will not make significant progress.</span></span> <span data-ttu-id="dc0e8-142">如果当前大多数线程都位于同一个进程中，那么其他进程中的线程被排入计划的频率会变低。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-142">If most of the current threads are in one process, threads in other processes are scheduled less frequently.</span></span>  
  
-   <span data-ttu-id="dc0e8-143">控制包含多个线程的代码执行非常复杂，可能会导致许多 bug 出现。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-143">Controlling code execution with many threads is complex, and can be a source of many bugs.</span></span>  
  
-   <span data-ttu-id="dc0e8-144">若要销毁线程，必须了解可能会发生的情况，并处理这些问题。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-144">Destroying threads requires knowing what could happen and handling those issues.</span></span>  
  
 <span data-ttu-id="dc0e8-145">提供对资源的共享访问权限可能会产生冲突。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-145">Providing shared access to resources can create conflicts.</span></span> <span data-ttu-id="dc0e8-146">为避免冲突，必须同步或控制对共享资源的访问。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-146">To avoid conflicts, you must synchronize, or control the access to, shared resources.</span></span> <span data-ttu-id="dc0e8-147">如果无法正确同步访问（在相同或不同的应用域中），可能会导致问题发生，如死锁（在一个线程等待另一个线程完成时，两个线程停止响应）和争用条件（由于意外严重依赖两个事件的时间而导致的异常后果）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-147">Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).</span></span> <span data-ttu-id="dc0e8-148">系统提供同步对象，可用于协调多个线程之间的资源共享。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-148">The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.</span></span> <span data-ttu-id="dc0e8-149">减少线程数量可以简化资源同步。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-149">Reducing the number of threads makes it easier to synchronize resources.</span></span>  
  
 <span data-ttu-id="dc0e8-150">需要同步的资源包括：</span><span class="sxs-lookup"><span data-stu-id="dc0e8-150">Resources that require synchronization include:</span></span>  
  
-   <span data-ttu-id="dc0e8-151">系统资源（如通信端口）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-151">System resources (such as communications ports).</span></span>  
  
-   <span data-ttu-id="dc0e8-152">多个进程共享的资源（如文件句柄）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-152">Resources shared by multiple processes (such as file handles).</span></span>  
  
-   <span data-ttu-id="dc0e8-153">多个线程访问的一个应用域的资源（如全局字段、静态字段和实例字段）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-153">The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.</span></span>  
  
### <a name="threading-and-application-design"></a><span data-ttu-id="dc0e8-154">线程处理和应用设计</span><span class="sxs-lookup"><span data-stu-id="dc0e8-154">Threading and Application Design</span></span>  
 <span data-ttu-id="dc0e8-155">一般来说，若要处理多个线程，以完成耗时相对较短且不会阻止其他线程的任务，且无需对任务有任何特定的计划，使用 <xref:System.Threading.ThreadPool> 类是最简单的方法。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-155">In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.</span></span> <span data-ttu-id="dc0e8-156">不过，鉴于多种原因，也可以创建自己的线程：</span><span class="sxs-lookup"><span data-stu-id="dc0e8-156">However, there are a number of reasons to create your own threads:</span></span>  
  
-   <span data-ttu-id="dc0e8-157">如果需要任务有特定的优先级。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-157">If you need a task to have a particular priority.</span></span>  
  
-   <span data-ttu-id="dc0e8-158">如果有运行时间可能很长（因此可能会阻止其他任务）的任务。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-158">If you have a task that might run a long time (and therefore block other tasks).</span></span>  
  
-   <span data-ttu-id="dc0e8-159">如果需要将线程添加到单线程单元（所有 ThreadPool 线程都位于多线程单元中）。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-159">If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).</span></span>  
  
-   <span data-ttu-id="dc0e8-160">如果需要与线程相关联的稳定标识。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-160">If you need a stable identity associated with the thread.</span></span> <span data-ttu-id="dc0e8-161">例如，应使用专用线程，以中止相应线程、暂停它或按名称发现它。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-161">For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.</span></span>  
  
-   <span data-ttu-id="dc0e8-162">如果需要运行与用户界面交互的后台线程，.NET Framework 版本 2.0 提供了 <xref:System.ComponentModel.BackgroundWorker> 组件，以使用事件和跨线程封送与用户界面线程进行通信。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-162">If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.</span></span>  
  
### <a name="threading-and-exceptions"></a><span data-ttu-id="dc0e8-163">线程处理和异常</span><span class="sxs-lookup"><span data-stu-id="dc0e8-163">Threading and Exceptions</span></span>  
 <span data-ttu-id="dc0e8-164">请务必处理线程异常。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-164">Do handle exceptions in threads.</span></span> <span data-ttu-id="dc0e8-165">未经处理的线程（甚至后台线程）异常通常会终止进程。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-165">Unhandled exceptions in threads, even background threads, generally terminate the process.</span></span> <span data-ttu-id="dc0e8-166">以下为此规则的三种例外情况：</span><span class="sxs-lookup"><span data-stu-id="dc0e8-166">There are three exceptions to this rule:</span></span>  
  
-   <span data-ttu-id="dc0e8-167">由于 <xref:System.Threading.Thread.Abort%2A> 得到调用，因此 <xref:System.Threading.ThreadAbortException> 在线程中抛出。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-167">A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.</span></span>  
  
-   <span data-ttu-id="dc0e8-168">由于正在卸载应用域，因此线程抛出 <xref:System.AppDomainUnloadedException>。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-168">An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.</span></span>  
  
-   <span data-ttu-id="dc0e8-169">公共语言运行时或主机进程将终止该线程。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-169">The common language runtime or a host process terminates the thread.</span></span>  
  
 <span data-ttu-id="dc0e8-170">有关详细信息，请参阅[托管线程异常](../../../docs/standard/threading/exceptions-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-170">For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dc0e8-171">在 .NET framework 版本 1.0 和 1.1 中，公共语言运行时以无提示方式捕获一些异常，例如线程池中的线程异常。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-171">In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.</span></span> <span data-ttu-id="dc0e8-172">这可能会损坏应用状态，并最终导致应用挂起，此问题的调试难度非常大。</span><span class="sxs-lookup"><span data-stu-id="dc0e8-172">This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dc0e8-173">请参阅</span><span class="sxs-lookup"><span data-stu-id="dc0e8-173">See also</span></span>

- <xref:System.Threading.ThreadPool>  
- <xref:System.ComponentModel.BackgroundWorker>  
- [<span data-ttu-id="dc0e8-174">为多线程处理同步数据</span><span class="sxs-lookup"><span data-stu-id="dc0e8-174">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="dc0e8-175">托管线程池</span><span class="sxs-lookup"><span data-stu-id="dc0e8-175">The Managed Thread Pool</span></span>](../../../docs/standard/threading/the-managed-thread-pool.md)
