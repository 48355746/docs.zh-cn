---
title: 如何：比较字符串 - C# 指南
description: 了解在区分或不区分大小写以及使用或不使用区域性特定的排序情况下，如何对字符串值进行比较和排序
ms.date: 03/20/2018
helpviewer_keywords:
- strings [C#], comparison
- comparing strings [C#]
ms.openlocfilehash: 36529414d5b51e9e4ade7447ff6e5e908e5153ab
ms.sourcegitcommit: c93fd5139f9efcf6db514e3474301738a6d1d649
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/27/2018
ms.locfileid: "50188568"
---
# <a name="how-to-compare-strings-in-c"></a><span data-ttu-id="f59ad-103">如何：比较 C\# 中的字符串</span><span class="sxs-lookup"><span data-stu-id="f59ad-103">How to compare strings in C\#</span></span>

<span data-ttu-id="f59ad-104">通过比较字符串可以回答两个问题，一个是：“这两个字符串相等吗？”</span><span class="sxs-lookup"><span data-stu-id="f59ad-104">You compare strings to answer one of two questions: "Are these two strings equal?"</span></span> <span data-ttu-id="f59ad-105">另一个是“排序时，应该按什么顺序排列这些字符串？”</span><span class="sxs-lookup"><span data-stu-id="f59ad-105">or "In what order should these strings be placed when sorting them?"</span></span>

<span data-ttu-id="f59ad-106">这两个问题非常复杂，因为字符串比较受很多因素的影响：</span><span class="sxs-lookup"><span data-stu-id="f59ad-106">Those two questions are complicated by factors that affect string comparisons:</span></span>

- <span data-ttu-id="f59ad-107">可以选择序号比较或语义比较。</span><span class="sxs-lookup"><span data-stu-id="f59ad-107">You can choose an ordinal or linguistic comparison.</span></span>
- <span data-ttu-id="f59ad-108">可以选择是否区分大小写。</span><span class="sxs-lookup"><span data-stu-id="f59ad-108">You can choose if case matters.</span></span>
- <span data-ttu-id="f59ad-109">可以选择区域性特定的比较。</span><span class="sxs-lookup"><span data-stu-id="f59ad-109">You can choose culture specific comparisons.</span></span>
- <span data-ttu-id="f59ad-110">语义比较取决于区域性和平台。</span><span class="sxs-lookup"><span data-stu-id="f59ad-110">Linguistic comparisons are culture and platform dependent.</span></span>

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="f59ad-111">在比较字符串时定义它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-111">When you compare strings, you define an order among them.</span></span> <span data-ttu-id="f59ad-112">通过比较决定字符串的序列。</span><span class="sxs-lookup"><span data-stu-id="f59ad-112">Comparisons are used to sort a sequence of strings.</span></span> <span data-ttu-id="f59ad-113">确定序列顺序后，软件和人工都可以更轻松地进行搜索。</span><span class="sxs-lookup"><span data-stu-id="f59ad-113">Once the sequence is in a known order, it is easier to search, both for software and for humans.</span></span> <span data-ttu-id="f59ad-114">其他比较可能会检查字符串是否相同。</span><span class="sxs-lookup"><span data-stu-id="f59ad-114">Other comparisons may check if strings are the same.</span></span> <span data-ttu-id="f59ad-115">这种一致性检查与相等性检查类似，但是也有一些不同之处，例如可能会忽略大小写的差异。</span><span class="sxs-lookup"><span data-stu-id="f59ad-115">These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</span></span>

## <a name="default-ordinal-comparisons"></a><span data-ttu-id="f59ad-116">默认的序号比较</span><span class="sxs-lookup"><span data-stu-id="f59ad-116">Default ordinal comparisons</span></span>

<span data-ttu-id="f59ad-117">最常见的操作：<xref:System.String.CompareTo%2A?displayProperty=nameWithType> 和 <xref:System.String.Equals%2A?displayProperty=nameWithType> 或 <xref:System.String.op_Equality%2A?displayProperty=nameWithType> 使用序号比较（一种区分大小写的比较）并使用当前区域性。</span><span class="sxs-lookup"><span data-stu-id="f59ad-117">The most common operations, <xref:System.String.CompareTo%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> or <xref:System.String.op_Equality%2A?displayProperty=nameWithType> use an ordinal comparison, a case-sensitive comparison, and use the current culture.</span></span> <span data-ttu-id="f59ad-118">结果如下例所示。</span><span class="sxs-lookup"><span data-stu-id="f59ad-118">The results are shown in the following example.</span></span>

[!code-csharp-interactive[Comparing strings using an ordinal comparison](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#1)]

<span data-ttu-id="f59ad-119">序号比较在比较字符串时不会考虑语义规则。</span><span class="sxs-lookup"><span data-stu-id="f59ad-119">Ordinal comparisons do not take linguistic rules into account when comparing strings.</span></span> <span data-ttu-id="f59ad-120">他们将按字符比较字符串。</span><span class="sxs-lookup"><span data-stu-id="f59ad-120">They will compare the strings character by character.</span></span> <span data-ttu-id="f59ad-121">区分大小写的比较在比较时使用大写。</span><span class="sxs-lookup"><span data-stu-id="f59ad-121">Case-sensitive comparisons use capitalization in their comparisons.</span></span> <span data-ttu-id="f59ad-122">这种默认的比较方法最重要的一点是：由于使用当前区域性，所以比较结果取决于运行比较的计算机的区域设置以及语言设置。</span><span class="sxs-lookup"><span data-stu-id="f59ad-122">The most important point about these default comparison methods is that because they use the current culture, the results depend on the locale and language settings of the machine where they run.</span></span> <span data-ttu-id="f59ad-123">对于需要在多个计算机或位置保持顺序一致的情况，这种比较并不适用。</span><span class="sxs-lookup"><span data-stu-id="f59ad-123">These comparisons are unsuitable for comparisons where order should be consistent across machines or locations.</span></span>

## <a name="case-insensitive-ordinal-comparisons"></a><span data-ttu-id="f59ad-124">不区分大小写的序号比较</span><span class="sxs-lookup"><span data-stu-id="f59ad-124">Case-insensitive ordinal comparisons</span></span>

<span data-ttu-id="f59ad-125"><xref:System.String.Equals%2A?displayProperty=nameWithType> 方法允许指定 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 的 <xref:System.StringComparison> 值</span><span class="sxs-lookup"><span data-stu-id="f59ad-125">The <xref:System.String.Equals%2A?displayProperty=nameWithType> method enables you to specify a <xref:System.StringComparison> value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span></span>
<span data-ttu-id="f59ad-126">用于指定不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="f59ad-126">to specify a case-insensitive comparison.</span></span> <span data-ttu-id="f59ad-127">还有一个静态 <xref:System.String.Compare%2A> 方法，其中包括用于指定不区分大小写比较的布尔参数。</span><span class="sxs-lookup"><span data-stu-id="f59ad-127">There is also a static <xref:System.String.Compare%2A> method that includes a boolean argument to specify case-insensitive comparisons.</span></span> <span data-ttu-id="f59ad-128">如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="f59ad-128">These are shown in the following code:</span></span>

[!code-csharp-interactive[Comparing strings ignoring case](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#2)]

## <a name="linguistic-comparisons"></a><span data-ttu-id="f59ad-129">语义比较</span><span class="sxs-lookup"><span data-stu-id="f59ad-129">Linguistic comparisons</span></span>

<span data-ttu-id="f59ad-130">可以使用当前区域性的语义规则来对字符串进行排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-130">Strings can also be ordered using linguistic rules for the current culture.</span></span>
<span data-ttu-id="f59ad-131">这有时被称为“文字排序顺序”。</span><span class="sxs-lookup"><span data-stu-id="f59ad-131">This is sometimes referred to as "word sort order."</span></span> <span data-ttu-id="f59ad-132">在执行语义比较时，一些非字母数字的 Unicode 字符可能分配有特殊的权重。</span><span class="sxs-lookup"><span data-stu-id="f59ad-132">When you perform a linguistic comparison, some nonalphanumeric Unicode characters might have special weights assigned.</span></span> <span data-ttu-id="f59ad-133">例如，连字符“-”分配的权重可能很小，所以“co-op”和“coop”在排序顺序中会彼此相邻。</span><span class="sxs-lookup"><span data-stu-id="f59ad-133">For example, the hyphen "-" may have a very small weight assigned to it so that "co-op" and "coop" appear next to each other in sort order.</span></span> <span data-ttu-id="f59ad-134">此外，一些 Unicode 字符可能会与一些字母数字字符相同。</span><span class="sxs-lookup"><span data-stu-id="f59ad-134">In addition, some Unicode characters may be equivalent to a sequence of alphanumeric characters.</span></span> <span data-ttu-id="f59ad-135">下面以德语短句“他们在街上跳舞。”为例，</span><span class="sxs-lookup"><span data-stu-id="f59ad-135">The following example uses the phrase "They dance in the street."</span></span> <span data-ttu-id="f59ad-136">这两个短句分别使用了“ss”和“ß”。</span><span class="sxs-lookup"><span data-stu-id="f59ad-136">in German with the "ss" and 'ß'.</span></span> <span data-ttu-id="f59ad-137">（在 Windows 系统中）从语义上说，“ss”在“en-US”和“de-DE”区域性中都等同于德语中的“'ß”。</span><span class="sxs-lookup"><span data-stu-id="f59ad-137">Linguistically (in Windows), "ss" is equal to the German Essetz: 'ß' character in both "en-US" and "de-DE" cultures.</span></span>

[!code-csharp-interactive[Comparing strings using linguistic rules](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#3)]

<span data-ttu-id="f59ad-138">此示例说明了语义比较是依赖于操作系统的。</span><span class="sxs-lookup"><span data-stu-id="f59ad-138">This sample demonstrates the operating system dependent nature of linguistic comparisons.</span></span> <span data-ttu-id="f59ad-139">交互式窗口的主机为 Linux 主机。</span><span class="sxs-lookup"><span data-stu-id="f59ad-139">The host for the interactive window is a Linux host.</span></span> <span data-ttu-id="f59ad-140">语义比较和序号比较的结果是一样的。</span><span class="sxs-lookup"><span data-stu-id="f59ad-140">The linguistic and ordinal comparisons produce the same results.</span></span> <span data-ttu-id="f59ad-141">如果在 Windows 主机上运行同样的示例，会看到如下输出内容：</span><span class="sxs-lookup"><span data-stu-id="f59ad-141">If you ran this same sample on a Windows host, you would see the following output:</span></span>

```console
<coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="f59ad-142">在 Windows 上，从语义比较改为序号比较时，“cop”、“coop”和“co-op”的排序顺序产生了变化。</span><span class="sxs-lookup"><span data-stu-id="f59ad-142">On Windows, the sort order of "cop", "coop", and "co-op" change when you change from a linguistic comparison to an ordinal comparison.</span></span> <span data-ttu-id="f59ad-143">使用不同的比较类型时，这两个德语句子的比较结果也就不同了。</span><span class="sxs-lookup"><span data-stu-id="f59ad-143">The two German sentences also compare differently using the different comparison types.</span></span>

## <a name="comparisons-using-specific-cultures"></a><span data-ttu-id="f59ad-144">使用特定区域性的比较</span><span class="sxs-lookup"><span data-stu-id="f59ad-144">Comparisons using specific cultures</span></span>

<span data-ttu-id="f59ad-145">此示例存储当前区域性的 <xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="f59ad-145">This sample stores <xref:System.Globalization.CultureInfo> for the current culture.</span></span>
<span data-ttu-id="f59ad-146">在当前线程对象上可以设置并检索原始区域性。</span><span class="sxs-lookup"><span data-stu-id="f59ad-146">The original culture can be set and retrieved on the current thread object.</span></span> <span data-ttu-id="f59ad-147">使用 <xref:System.StringComparison.CurrentCulture> 值执行比较以确保执行的是区域性特定的比较。</span><span class="sxs-lookup"><span data-stu-id="f59ad-147">The comparisons are performed using the <xref:System.StringComparison.CurrentCulture> value to ensure a culture-specific comparison.</span></span>

<span data-ttu-id="f59ad-148">所用的区域性会对语义比较产生影响。</span><span class="sxs-lookup"><span data-stu-id="f59ad-148">The culture used affects linguistic comparisons.</span></span> <span data-ttu-id="f59ad-149">以下示例展示使用“en-US”区域性和“de-DE”区域性对两个德语句子进行比较的结果：</span><span class="sxs-lookup"><span data-stu-id="f59ad-149">The following example shows the results of comparing the two German sentences using the "en-US" culture and the "de-DE" culture:</span></span>

[!code-csharp-interactive[Comparing strings across cultures](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#4)]

<span data-ttu-id="f59ad-150">区分区域性的比较通常用于对用户输入的字符串以及用户输入的其他字符串进行比较和排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-150">Culture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users.</span></span> <span data-ttu-id="f59ad-151">字符和这些字符的排序约定可能会根据用户计算机的区域设置而有所不同。</span><span class="sxs-lookup"><span data-stu-id="f59ad-151">The characters and sorting conventions of these strings might vary depending on the locale of the user's computer.</span></span> <span data-ttu-id="f59ad-152">即使是包含相同字符的字符串，也可能因当前线程的区域性而具有不同的排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-152">Even strings that contain identical characters might sort differently depending on the culture of the current thread.</span></span> <span data-ttu-id="f59ad-153">此外，请在本地 Windows 计算机上尝试下列示例代码，将得到下列结果：</span><span class="sxs-lookup"><span data-stu-id="f59ad-153">In addition, try this sample code locally on a Windows machine, and you will the following results:</span></span>

```console
<coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="f59ad-154">语义比较取决于当前区域性以及操作系统。</span><span class="sxs-lookup"><span data-stu-id="f59ad-154">Linguistic comparisons are dependent on the current culture, and are OS dependent.</span></span> <span data-ttu-id="f59ad-155">在进行字符串比较时，需要考虑这些内容。</span><span class="sxs-lookup"><span data-stu-id="f59ad-155">You must take that into account when you work with string comparisons.</span></span>

## <a name="linguistic-sorting-and-searching-strings-in-arrays"></a><span data-ttu-id="f59ad-156">数组中的语义排序和字符串搜索</span><span class="sxs-lookup"><span data-stu-id="f59ad-156">Linguistic sorting and searching strings in arrays</span></span>

<span data-ttu-id="f59ad-157">以下示例演示如何在数组中使用依赖当前区域性的语义比较对字符串进行排序和搜索。</span><span class="sxs-lookup"><span data-stu-id="f59ad-157">The following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture.</span></span> <span data-ttu-id="f59ad-158">使用采用 <xref:System.StringComparer?displayProperty=nameWithType> 参数的静态 <xref:System.Array> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59ad-158">You use the static <xref:System.Array> methods that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter.</span></span>

<span data-ttu-id="f59ad-159">此示例演示如何使用当前区域性对字符串数组进行排序：</span><span class="sxs-lookup"><span data-stu-id="f59ad-159">This example shows how to sort an array of strings using the current culture:</span></span>

[!code-csharp-interactive[Sorting an array of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#5)]

<span data-ttu-id="f59ad-160">对数组进行排序后，可以使用二分搜索法搜索条目。</span><span class="sxs-lookup"><span data-stu-id="f59ad-160">Once the array is sorted, you can search for entries using a binary search.</span></span> <span data-ttu-id="f59ad-161">二分搜索法从集合的中间开始搜索，判断集合的哪一半包含所找字符串。</span><span class="sxs-lookup"><span data-stu-id="f59ad-161">A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string.</span></span> <span data-ttu-id="f59ad-162">后续的每个比较都将集合的剩余部分再次对半分开。</span><span class="sxs-lookup"><span data-stu-id="f59ad-162">Each subsequent comparison subdivides the remaining part of the collection in half.</span></span>  <span data-ttu-id="f59ad-163">使用 <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType> 对数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-163">The array is sorted using <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f59ad-164">本地函数 `ShowWhere` 显示发现字符串所在位置的信息。</span><span class="sxs-lookup"><span data-stu-id="f59ad-164">The local function `ShowWhere` displays information about where the string was found.</span></span> <span data-ttu-id="f59ad-165">如果未找到字符串，返回的值会指示它可能会在的位置（如果找到）。</span><span class="sxs-lookup"><span data-stu-id="f59ad-165">If the string was not found, the returned value indicates where it would be if it were found.</span></span>

[!code-csharp-interactive[Searching in a sorted array](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#6)]

## <a name="ordinal-sorting-and-searching-in-collections"></a><span data-ttu-id="f59ad-166">集合中的序号排序和搜索</span><span class="sxs-lookup"><span data-stu-id="f59ad-166">Ordinal sorting and searching in collections</span></span>

<span data-ttu-id="f59ad-167">以下代码使用 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 集合类存储字符串。</span><span class="sxs-lookup"><span data-stu-id="f59ad-167">The following code uses the <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> collection class to store strings.</span></span> <span data-ttu-id="f59ad-168">字符串是通过 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 方法排序的。</span><span class="sxs-lookup"><span data-stu-id="f59ad-168">The strings are sorted using the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59ad-169">此方法需要对两个字符串进行比较和排序的委托。</span><span class="sxs-lookup"><span data-stu-id="f59ad-169">This method needs a delegate that compares and orders two strings.</span></span> <span data-ttu-id="f59ad-170"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 方法提供该比较函数。</span><span class="sxs-lookup"><span data-stu-id="f59ad-170">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> method provides that comparison function.</span></span> <span data-ttu-id="f59ad-171">请运行示例并观察顺序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-171">Run the sample and observe the order.</span></span> <span data-ttu-id="f59ad-172">此排序操作使用区分大小写的序号排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-172">This sort operation uses an ordinal case sensitive sort.</span></span> <span data-ttu-id="f59ad-173">你要使用静态 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法指定不同的比较规则。</span><span class="sxs-lookup"><span data-stu-id="f59ad-173">You would use the static <xref:System.String.Compare%2A?displayProperty=nameWithType> methods to specify different comparison rules.</span></span>

[!code-csharp-interactive[Sorting a list of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#7)]

<span data-ttu-id="f59ad-174">排序后，可以使用二分搜索法对字符串列表进行搜索。</span><span class="sxs-lookup"><span data-stu-id="f59ad-174">Once sorted, the list of strings can be searched using a binary search.</span></span> <span data-ttu-id="f59ad-175">以下示例演示如何使用相同的比较函数搜索排序列表。</span><span class="sxs-lookup"><span data-stu-id="f59ad-175">The following sample shows how to search the sorted listed using the same comparison function.</span></span> <span data-ttu-id="f59ad-176">本地函数 `ShowWhere` 显示所查找的文本所在的位置或可能会在位置：</span><span class="sxs-lookup"><span data-stu-id="f59ad-176">The local function `ShowWhere` shows where the sought text is or would be:</span></span>

[!code-csharp-interactive[csProgGuideStrings#11](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#8)]

<span data-ttu-id="f59ad-177">在排序和搜索过程中，请始终确保使用相同的比较类型。</span><span class="sxs-lookup"><span data-stu-id="f59ad-177">Always make sure to use the same type of comparison for sorting and searching.</span></span> <span data-ttu-id="f59ad-178">使用不同的比较类型进行排序和搜索会产生意外的结果。</span><span class="sxs-lookup"><span data-stu-id="f59ad-178">Using different comparison types for sorting and searching produces unexpected results.</span></span>

<span data-ttu-id="f59ad-179">元素或键的类型为 `string` 时，<xref:System.Collections.Hashtable?displayProperty=nameWithType>、<xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 等集合类的构造函数具有 <xref:System.StringComparer?displayProperty=nameWithType> 参数。</span><span class="sxs-lookup"><span data-stu-id="f59ad-179">Collection classes such as <xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> have constructors that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter when the type of the elements or keys is `string`.</span></span> <span data-ttu-id="f59ad-180">通常，应尽可能使用这些构造函数，并指定 <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f59ad-180">In general, you should use these constructors whenever possible, and specify either <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

## <a name="reference-equality-and-string-interning"></a><span data-ttu-id="f59ad-181">引用相等性和字符串集中</span><span class="sxs-lookup"><span data-stu-id="f59ad-181">Reference equality and string interning</span></span>

<span data-ttu-id="f59ad-182">这些示例都没有使用 <xref:System.Object.ReferenceEquals%2A>。</span><span class="sxs-lookup"><span data-stu-id="f59ad-182">None of the samples have used <xref:System.Object.ReferenceEquals%2A>.</span></span> <span data-ttu-id="f59ad-183">此方法确定两个字符串是否为相同的对象。</span><span class="sxs-lookup"><span data-stu-id="f59ad-183">This method determines if two strings are the same object.</span></span> <span data-ttu-id="f59ad-184">这可能会在字符串比较中产生不一致的结果。</span><span class="sxs-lookup"><span data-stu-id="f59ad-184">This can lead to inconsistent results in string comparisons.</span></span> <span data-ttu-id="f59ad-185">以下示例演示了 C# 中的字符串集中功能。</span><span class="sxs-lookup"><span data-stu-id="f59ad-185">The following example demonstrates the *string interning* feature of C#.</span></span> <span data-ttu-id="f59ad-186">如果程序声明了 2 个或多个相同的字符串变量，则编译器会将其存储在同一位置。</span><span class="sxs-lookup"><span data-stu-id="f59ad-186">When a program declares two or more identical string variables, the compiler stores them all in the same location.</span></span> <span data-ttu-id="f59ad-187">通过调用 <xref:System.Object.ReferenceEquals%2A> 方法，可以看到这两个字符串实际上引用的是内存中的同一对象。</span><span class="sxs-lookup"><span data-stu-id="f59ad-187">By calling the <xref:System.Object.ReferenceEquals%2A> method, you can see that the two strings actually refer to the same object in memory.</span></span> <span data-ttu-id="f59ad-188">使用 <xref:System.String.Copy%2A?displayProperty=nameWithType> 方法可避免集中。</span><span class="sxs-lookup"><span data-stu-id="f59ad-188">Use the <xref:System.String.Copy%2A?displayProperty=nameWithType> method to avoid interning.</span></span> <span data-ttu-id="f59ad-189">创建副本后，两个字符串存储在不同位置（即使它们具有相同的值）。</span><span class="sxs-lookup"><span data-stu-id="f59ad-189">After the copy has been made, the two strings have different storage locations, even though they have the same value.</span></span> <span data-ttu-id="f59ad-190">运行下列示例以显示字符串 `a` 和 `b` 是集中的，也就是说它们共享相同的存储。</span><span class="sxs-lookup"><span data-stu-id="f59ad-190">Run the following sample to show that strings `a` and `b` are *interned* meaning they share the same storage.</span></span> <span data-ttu-id="f59ad-191">字符串 `a` 和 `c` 不是。</span><span class="sxs-lookup"><span data-stu-id="f59ad-191">The strings `a` and `c` are not.</span></span>

[!code-csharp-interactive[Demonstrating string interning](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#9)]

> [!NOTE]
> <span data-ttu-id="f59ad-192">测试字符串是否相等时，使用的方法应显式指定要执行的比较类型。</span><span class="sxs-lookup"><span data-stu-id="f59ad-192">When you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform.</span></span> <span data-ttu-id="f59ad-193">你的代码具备更强的可维护性和可读性。</span><span class="sxs-lookup"><span data-stu-id="f59ad-193">Your code is much more maintainable and readable.</span></span> <span data-ttu-id="f59ad-194">重载采用了 <xref:System.StringComparison> 枚举参数的 <xref:System.String?displayProperty=nameWithType> 和 <xref:System.Array?displayProperty=nameWithType> 类的方法。</span><span class="sxs-lookup"><span data-stu-id="f59ad-194">Use the overloads of the methods of the <xref:System.String?displayProperty=nameWithType> and <xref:System.Array?displayProperty=nameWithType> classes that take a <xref:System.StringComparison> enumeration parameter.</span></span> <span data-ttu-id="f59ad-195">指定要执行的比较类型。</span><span class="sxs-lookup"><span data-stu-id="f59ad-195">You specify which type of comparison to perform.</span></span> <span data-ttu-id="f59ad-196">在测试相等性时，请避免使用 `==` 和 `!=` 运算符。</span><span class="sxs-lookup"><span data-stu-id="f59ad-196">Avoid using the `==` and `!=` operators when you test for equality.</span></span> <span data-ttu-id="f59ad-197"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 实例方法始终执行区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="f59ad-197">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance methods always perform an ordinal case-sensitive comparison.</span></span> <span data-ttu-id="f59ad-198">它们主要适用于按字母顺序进行的字符串排序。</span><span class="sxs-lookup"><span data-stu-id="f59ad-198">They are primarily suited for ordering strings alphabetically.</span></span>

## <a name="see-also"></a><span data-ttu-id="f59ad-199">请参阅</span><span class="sxs-lookup"><span data-stu-id="f59ad-199">See also</span></span>

- <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>  
- <xref:System.StringComparer?displayProperty=nameWithType>  
- [<span data-ttu-id="f59ad-200">字符串</span><span class="sxs-lookup"><span data-stu-id="f59ad-200">Strings</span></span>](../programming-guide/strings/index.md)  
- [<span data-ttu-id="f59ad-201">比较字符串</span><span class="sxs-lookup"><span data-stu-id="f59ad-201">Comparing Strings</span></span>](../../standard/base-types/comparing.md)  
- [<span data-ttu-id="f59ad-202">对应用程序进行全球化和本地化</span><span class="sxs-lookup"><span data-stu-id="f59ad-202">Globalizing and Localizing Applications</span></span>](/visualstudio/ide/globalizing-and-localizing-applications)
