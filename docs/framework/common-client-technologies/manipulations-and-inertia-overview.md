---
title: 操作和惯性概述
ms.date: 03/30/2017
ms.assetid: dd31b89b-eab6-45a1-8d0b-11e0eb84b234
ms.openlocfilehash: 6396c174b341b5ae937fa931488ee1bd3a5fcbd5
ms.sourcegitcommit: c93fd5139f9efcf6db514e3474301738a6d1d649
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/27/2018
ms.locfileid: "50187814"
---
# <a name="manipulations-and-inertia-overview"></a><span data-ttu-id="83183-102">操作和惯性概述</span><span class="sxs-lookup"><span data-stu-id="83183-102">Manipulations and Inertia Overview</span></span>
<span data-ttu-id="83183-103">操作使用户可借助操控器移动、旋转用户界面 (UI) 元素以及调整它的大小。</span><span class="sxs-lookup"><span data-stu-id="83183-103">*Manipulations* enable users to move, rotate, and resize user interface (UI) elements by using *manipulators*.</span></span> <span data-ttu-id="83183-104">操控器是指鼠标或（在可触摸情况下）触笔或手指。</span><span class="sxs-lookup"><span data-stu-id="83183-104">A manipulator represents a mouse or (in a touch-enabled scenario) a stylus or a finger.</span></span>  
  
 <span data-ttu-id="83183-105">通过模拟元素上的摩擦力，惯性模拟真实世界中 UI 元素的移动行为。</span><span class="sxs-lookup"><span data-stu-id="83183-105">*Inertia* emulates real-world behavior for UI elements that are in motion by simulating friction forces on the elements.</span></span> <span data-ttu-id="83183-106">这使元素逐渐放慢移动速度（线性速度和角速度）至最终停止。</span><span class="sxs-lookup"><span data-stu-id="83183-106">This enables elements to gradually slow their movement (both linear and angular) before coming to a stop.</span></span> <span data-ttu-id="83183-107">本文将介绍 .NET Framework 的操作和惯性。</span><span class="sxs-lookup"><span data-stu-id="83183-107">This article provides an introduction to manipulations and inertia for the .NET Framework.</span></span>  
  
## <a name="manipulations"></a><span data-ttu-id="83183-108">操作</span><span class="sxs-lookup"><span data-stu-id="83183-108">Manipulations</span></span>  
 <span data-ttu-id="83183-109">操作将操控器的集合视为复合对象。</span><span class="sxs-lookup"><span data-stu-id="83183-109">A manipulation treats a collection of manipulators as a composite object.</span></span> <span data-ttu-id="83183-110">应用程序可跟踪复合对象（而非单个组件）的更改。</span><span class="sxs-lookup"><span data-stu-id="83183-110">An application can track the changes to the composite object instead of the individual components.</span></span>  
  
 <span data-ttu-id="83183-111">请注意下图中的图像。</span><span class="sxs-lookup"><span data-stu-id="83183-111">Consider the image in the following illustration.</span></span> <span data-ttu-id="83183-112">用户可使用两个操控器移动、旋转和缩放图像。</span><span class="sxs-lookup"><span data-stu-id="83183-112">A user can use two manipulators to move, rotate, and scale the image.</span></span> <span data-ttu-id="83183-113">每个操控器的更改均由其他操控器统一解释。</span><span class="sxs-lookup"><span data-stu-id="83183-113">The changes to each manipulator are interpreted together with the other manipulators.</span></span>  
  
 <span data-ttu-id="83183-114">例如，如果图像上有两个操控器（1 和 2），且操控器 1 沿 +Y 方向（向下）移动，则图像的更改取决于操控器 2 执行的操作。</span><span class="sxs-lookup"><span data-stu-id="83183-114">For example, if you have two manipulators (1 and 2) on the image, and you move manipulator 1 in a +Y direction (down), the change to the image depends on what happens to manipulator 2.</span></span> <span data-ttu-id="83183-115">如果操控器 2 也沿 +Y 方向（向下）移动，则图像只沿 +Y 方向移动。</span><span class="sxs-lookup"><span data-stu-id="83183-115">If manipulator 2 also moves in the +Y direction (down), the image simply moves in the +Y direction.</span></span> <span data-ttu-id="83183-116">但是如果操控器 2 未做任何更改，或沿 -Y 方向（向上）移动，则图像变小或旋转。</span><span class="sxs-lookup"><span data-stu-id="83183-116">But if manipulator 2 does not change, or it moves in a -Y direction (up), the image is made smaller or rotated.</span></span>  
  
 <span data-ttu-id="83183-117">![两根手指进行操作的虚拟照片。](../../../docs/framework/common-client-technologies/media/manipulation-resize.png "Manipulation_Resize")</span><span class="sxs-lookup"><span data-stu-id="83183-117">![A virtual photo that two fingers are manipulating.](../../../docs/framework/common-client-technologies/media/manipulation-resize.png "Manipulation_Resize")</span></span>  
  
 <span data-ttu-id="83183-118">由两个操控器操作的图像</span><span class="sxs-lookup"><span data-stu-id="83183-118">An image being manipulated by two manipulators</span></span>  
  
 <span data-ttu-id="83183-119">操作处理提供一个框架，用于监视操控器子集并将其解释为共同合作，而非独立操作。</span><span class="sxs-lookup"><span data-stu-id="83183-119">Manipulation processing provides a framework that monitors a subset of manipulators and interprets them as if they are acting together, instead of independently.</span></span> <span data-ttu-id="83183-120">可同时创建多个操作处理器对象，每个对象对应一个要在应用程序中操作的 UI 元素。</span><span class="sxs-lookup"><span data-stu-id="83183-120">You can create several manipulation processor objects simultaneously, one for each UI element to be manipulated in an application.</span></span> <span data-ttu-id="83183-121">向操作处理器通知要观察哪个输入设备，并通过 [.NET 事件](../../../docs/standard/events/index.md)报告操作。</span><span class="sxs-lookup"><span data-stu-id="83183-121">A manipulation processor is informed of which input devices to observe and it reports manipulations through [.NET events](../../../docs/standard/events/index.md).</span></span>  
  
 <span data-ttu-id="83183-122">操作处理器不具备正在操作的特定元素的相关信息。</span><span class="sxs-lookup"><span data-stu-id="83183-122">A manipulation processor does not have information about the particular element that is being manipulated.</span></span> <span data-ttu-id="83183-123">应用程序分别将更改应用于应用程序特定的元素。</span><span class="sxs-lookup"><span data-stu-id="83183-123">An application separately applies the changes to an application-specific element.</span></span> <span data-ttu-id="83183-124">例如，应用程序对图像应用转换，或者进行重绘以在其新位置或以新大小或方向进行显示。</span><span class="sxs-lookup"><span data-stu-id="83183-124">For example, an application applies transformations to an image or redraws it to display it at its new location or with a new size or orientation.</span></span>  
  
 <span data-ttu-id="83183-125">操作专用于二维 (2-D) [仿射转换](/windows/desktop/gdiplus/-gdiplus-transformations-use)。</span><span class="sxs-lookup"><span data-stu-id="83183-125">Manipulations are designed for two-dimensional (2-D) [affine transformations](/windows/desktop/gdiplus/-gdiplus-transformations-use).</span></span> <span data-ttu-id="83183-126">这些转换包括平移、旋转和缩放。</span><span class="sxs-lookup"><span data-stu-id="83183-126">These transformations include translate, rotate, and scale.</span></span>  
  
### <a name="parts-of-a-manipulation"></a><span data-ttu-id="83183-127">操作的各个部分</span><span class="sxs-lookup"><span data-stu-id="83183-127">Parts of a Manipulation</span></span>  
 <span data-ttu-id="83183-128">操作是 <xref:System.Windows.Input.Manipulations.Manipulator2D> 对象的集合。</span><span class="sxs-lookup"><span data-stu-id="83183-128">A manipulation is a collection of <xref:System.Windows.Input.Manipulations.Manipulator2D> objects.</span></span> <span data-ttu-id="83183-129">此聚合操作表示为原点和椭圆。</span><span class="sxs-lookup"><span data-stu-id="83183-129">This aggregate manipulation is represented by an origin point and an ellipse.</span></span> <span data-ttu-id="83183-130">原点是正在操作元素的所有操控器的平均位置。</span><span class="sxs-lookup"><span data-stu-id="83183-130">The origin point is the average position of all manipulators that are manipulating an element.</span></span> <span data-ttu-id="83183-131">椭圆的半径是原点到每个 <xref:System.Windows.Input.Manipulations.Manipulator2D> 对象的平均距离。</span><span class="sxs-lookup"><span data-stu-id="83183-131">The ellipse has a radius that is the average distance from the origin to each of the <xref:System.Windows.Input.Manipulations.Manipulator2D> objects.</span></span>  
  
 <span data-ttu-id="83183-132">![操作的各部分。](../../../docs/framework/common-client-technologies/media/manipulation-definition.png "Manipulation_Definition")</span><span class="sxs-lookup"><span data-stu-id="83183-132">![The parts of a manipulation.](../../../docs/framework/common-client-technologies/media/manipulation-definition.png "Manipulation_Definition")</span></span>  
  
 <span data-ttu-id="83183-133">两个操控器（1 和 2）、一个原点和一个椭圆指定一个操作</span><span class="sxs-lookup"><span data-stu-id="83183-133">Two manipulators (1 and 2), an origin, and an ellipse specify a manipulation</span></span>  
  
 <span data-ttu-id="83183-134">当添加、移动或删除 UI 元素的操控器时，应用程序会调用 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> 方法更新 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> 对象。</span><span class="sxs-lookup"><span data-stu-id="83183-134">As manipulators are added, moved, or removed for a UI element, an application updates the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object by calling the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method.</span></span> <span data-ttu-id="83183-135">当首次执行操作时，引发<xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> 事件。</span><span class="sxs-lookup"><span data-stu-id="83183-135">When the manipulation first begins, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> event is raised.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="83183-136">操作处理在基于框架的更新环境中使用时效率更高。</span><span class="sxs-lookup"><span data-stu-id="83183-136">Manipulation processing is more efficient when used in a frame-based update environment.</span></span> <span data-ttu-id="83183-137">在 Microsoft XNA 应用程序中使用操作处理时，无需对此担忧，因为 XNA Framework 使用 [Game.Update](https://docs.microsoft.com/previous-versions/windows/xna/bb199616%28v%3dxnagamestudio.41%29) 方法提供了基于框架的更新。</span><span class="sxs-lookup"><span data-stu-id="83183-137">When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](https://docs.microsoft.com/previous-versions/windows/xna/bb199616%28v%3dxnagamestudio.41%29) method.</span></span> <span data-ttu-id="83183-138">但在其他环境（如 WinForms）中，则可能需要提供自己的基于框架的逻辑以便收集操作和定期将其作为批处理发送到 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="83183-138">In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch.</span></span>  
  
 <span data-ttu-id="83183-139">操控器的数量或位置发生变化时，引发 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> 事件。</span><span class="sxs-lookup"><span data-stu-id="83183-139">As the number of manipulators or their position change, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event is raised.</span></span> <span data-ttu-id="83183-140">传递至 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> 事件处理程序的 <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> 对象的属性指定自上次事件以来原点、缩放、旋转和平移中的更改。</span><span class="sxs-lookup"><span data-stu-id="83183-140">Properties of the <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> object that is passed to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event handler specify changes in origin, scale, rotation, and translation that have occurred since the last event.</span></span> <span data-ttu-id="83183-141">移动、添加或删除操控器时，将更改操作的原点。</span><span class="sxs-lookup"><span data-stu-id="83183-141">The origin of the manipulation changes when manipulators move, and when manipulators are added or removed.</span></span> <span data-ttu-id="83183-142">平移值指定操作包含的 X 或 Y 移动数量。</span><span class="sxs-lookup"><span data-stu-id="83183-142">Translation values specify how much X or Y movement the manipulation includes.</span></span>  
  
 <span data-ttu-id="83183-143">应用程序可使用新值重绘 UI 元素。</span><span class="sxs-lookup"><span data-stu-id="83183-143">Using the new values, an application redraws the UI element.</span></span>  
  
 <span data-ttu-id="83183-144">![在联系人 A 移到右边后执行的操作。](../../../docs/framework/common-client-technologies/media/manipulation-changed.png "Manipulation_Changed")</span><span class="sxs-lookup"><span data-stu-id="83183-144">![A manipulation after contact A moved to the right.](../../../docs/framework/common-client-technologies/media/manipulation-changed.png "Manipulation_Changed")</span></span>  
  
 <span data-ttu-id="83183-145">操控器 1 移动圆点并使其更改</span><span class="sxs-lookup"><span data-stu-id="83183-145">Manipulator 1 moves and causes the origin to change</span></span>  
  
 <span data-ttu-id="83183-146">删除 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> 对象中与操作关联的上个操控器时，引发 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> 事件。</span><span class="sxs-lookup"><span data-stu-id="83183-146">When the last manipulator that is associated with the manipulation is removed from the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event is raised.</span></span>  
  
### <a name="the-manipulation-processing-model"></a><span data-ttu-id="83183-147">操作处理模型</span><span class="sxs-lookup"><span data-stu-id="83183-147">The Manipulation Processing Model</span></span>  
 <span data-ttu-id="83183-148">操作处理器使用即用模型。</span><span class="sxs-lookup"><span data-stu-id="83183-148">A manipulation processor uses a direct-usage model.</span></span> <span data-ttu-id="83183-149">利用此简单模型，应用程序必须将任何输入事件的详细信息传递至操作处理器。</span><span class="sxs-lookup"><span data-stu-id="83183-149">With this simple model, an application must pass any input event details to the manipulation processor.</span></span> <span data-ttu-id="83183-150">输入事件可能由任何输入基元（如鼠标设备、触笔或手指）引发。</span><span class="sxs-lookup"><span data-stu-id="83183-150">An input event might be raised by any input primitive, such as a mouse device, a stylus, or a finger.</span></span> <span data-ttu-id="83183-151">此过程提供了直接筛选机制和简单的使用模型，因此应用程序可在必要时批处理输入事件。</span><span class="sxs-lookup"><span data-stu-id="83183-151">This process provides a direct filtering mechanism and a simple usage model, so the application can batch input events when it is necessary.</span></span>  
  
 <span data-ttu-id="83183-152">对于要在操作过程中包含输入基元的应用程序，会从输入基元的详细信息中创建 <xref:System.Windows.Input.Manipulations.Manipulator2D> 结构，并使用 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> 方法将此结构传递到操作处理器。</span><span class="sxs-lookup"><span data-stu-id="83183-152">For an application to include an input primitive in the manipulation process, it creates a <xref:System.Windows.Input.Manipulations.Manipulator2D> structure from the details of the input primitive, and passes the structure to the manipulation processor using the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method.</span></span> <span data-ttu-id="83183-153">然后，操作处理器会引发应用程序必须处理才能以适当方式更新可视组件的事件。</span><span class="sxs-lookup"><span data-stu-id="83183-153">The manipulation processor then raises events, which the application must handle to update the visual component in an appropriate way.</span></span>  
  
 <span data-ttu-id="83183-154">![直接使用模型的操作流。](../../../docs/framework/common-client-technologies/media/manipulation-flow.png "Manipulation_Flow")</span><span class="sxs-lookup"><span data-stu-id="83183-154">![The flow of the manipulations direct&#45;usage model.](../../../docs/framework/common-client-technologies/media/manipulation-flow.png "Manipulation_Flow")</span></span>  
  
 <span data-ttu-id="83183-155">操作处理模型</span><span class="sxs-lookup"><span data-stu-id="83183-155">The manipulation processing model</span></span>  
  
## <a name="inertia"></a><span data-ttu-id="83183-156">惯性</span><span class="sxs-lookup"><span data-stu-id="83183-156">Inertia</span></span>  
 <span data-ttu-id="83183-157">惯性处理器通过模拟真实世界的行为使应用程序能够推测 UI元素的位置、方向和其他属性。</span><span class="sxs-lookup"><span data-stu-id="83183-157">The inertia processor enables applications to extrapolate location, orientation, and other properties of a UI element by simulating real-world behavior.</span></span>  
  
 <span data-ttu-id="83183-158">例如，当用户轻击元素时，它可以继续移动、减速，然后慢慢停止。</span><span class="sxs-lookup"><span data-stu-id="83183-158">For instance, when a user flicks an element, it can continue moving, decelerate, and then slowly stop.</span></span> <span data-ttu-id="83183-159">惯性处理器实现此行为的方式是：使仿射二维值（原点、缩放、平移和旋转）在指定时间段内以指定的减速速率进行更改。</span><span class="sxs-lookup"><span data-stu-id="83183-159">The inertia processor implements this behavior by causing the affine 2-D values (origin, scale, translation, and rotation) to change over a specified time at a specified deceleration rate.</span></span>  
  
 <span data-ttu-id="83183-160">与操作处理一样，惯性处理器不具备任何特定 UI 元素的相关信息。</span><span class="sxs-lookup"><span data-stu-id="83183-160">As with manipulation processing, an inertia processor does not have information about any particular UI element.</span></span> <span data-ttu-id="83183-161">在响应 <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> 对象上引发的事件时，应用程序会将更改分别应用于应用程序特定的元素。</span><span class="sxs-lookup"><span data-stu-id="83183-161">In response to events that are raised on an <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> object, an application separately applies the changes to an application-specific element.</span></span>  
  
 <span data-ttu-id="83183-162">惯性处理和操作处理通常一同使用。</span><span class="sxs-lookup"><span data-stu-id="83183-162">Inertia processing and manipulation processing are often used together.</span></span> <span data-ttu-id="83183-163">它们的界面相似，并且引发的事件（在某些情况下）相同。</span><span class="sxs-lookup"><span data-stu-id="83183-163">Their interfaces are similar, and the events that they raise are (in some cases) identical.</span></span> <span data-ttu-id="83183-164">通常，在完成 UI 元素的操作时开始惯性处理。</span><span class="sxs-lookup"><span data-stu-id="83183-164">Generally, inertia processing begins when the manipulation of the UI element is completed.</span></span> <span data-ttu-id="83183-165">实现的方式如下：侦听 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> 事件并从此事件处理程序中启动惯性处理。</span><span class="sxs-lookup"><span data-stu-id="83183-165">This is accomplished by listening to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event and starting the inertia processing from that event handler.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="83183-166">请参阅</span><span class="sxs-lookup"><span data-stu-id="83183-166">See Also</span></span>  
 <xref:System.Windows.Input.Manipulations>
